module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var build_all_commander = __webpack_require__(3);

	var _ = function _(commander, mu_src_path, config) {
	    build_all_commander(commander, mu_src_path);
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("async-stacktrace");

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("word-wrap");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var create = __webpack_require__(4);

	var _ = function _(commander, mu_src_path) {
	    var success_message = 'build the tools and the project';
	    commander.command('build all').description('built the code and the project').action(function (project_name) {
	        console.log(success_message);
	    });
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ERR, word_wrap, fs, move_if_exists, copy_if_exists, modify_es6, convert_es6, modify_main_file, _;
	'use strict';
	ERR = __webpack_require__(1);
	word_wrap = __webpack_require__(2);
	fs = __webpack_require__(5);
	move_if_exists = __webpack_require__(45);
	copy_if_exists = __webpack_require__(46);
	modify_es6 = __webpack_require__(47);
	convert_es6 = __webpack_require__(54);
	modify_main_file = __webpack_require__(55);
	_ = function _(root_path, cb) {
	  var gen_path, proj_path, err;
	  gen_path = root_path + '/generated_local';
	  proj_path = gen_path + '/project';
	  move_if_exists(proj_path + '/node_modules', gen_path + '/project_node_modules', function (arguments, _$param0) {
	    err = _$param0;
	    if (ERR(err, cb)) {
	      return;
	    }
	    fs.remove(proj_path, function (arguments, _$param1) {
	      err = _$param1;
	      if (ERR(err, cb)) {
	        return;
	      }
	      fs.mkdirp(proj_path, function (arguments, _$param2) {
	        err = _$param2;
	        if (ERR(err, cb)) {
	          return;
	        }
	        fs.copy(root_path + '/_.es6', proj_path + '/_.es6', function (arguments, _$param3) {
	          err = _$param3;
	          if (ERR(err, cb)) {
	            return;
	          }
	          fs.copy(root_path + '/__test.es6', proj_path + '/__test.es6', function (arguments, _$param4) {
	            err = _$param4;
	            if (ERR(err, cb)) {
	              return;
	            }
	            copy_if_exists(root_path + '/submodules', proj_path + '/submodules', function (arguments, _$param5) {
	              err = _$param5;
	              if (ERR(err, cb)) {
	                return;
	              }
	              move_if_exists(root_path + '/project_node_modules', proj_path + '/node_modules', function (arguments, _$param6) {
	                err = _$param6;
	                if (ERR(err, cb)) {
	                  return;
	                }
	                modify_es6(proj_path, function (arguments, _$param7) {
	                  err = _$param7;
	                  if (ERR(err, cb)) {
	                    return;
	                  }
	                  modify_main_file(proj_path, function (arguments, _$param8) {
	                    err = _$param8;
	                    if (ERR(err, cb)) {
	                      return;
	                    }
	                    convert_es6(proj_path, function (arguments, _$param9) {
	                      err = _$param9;
	                      if (ERR(err, cb)) {
	                        return;
	                      }
	                      cb(null);
	                    }.bind(this, arguments));
	                  }.bind(this, arguments));
	                }.bind(this, arguments));
	              }.bind(this, arguments));
	            }.bind(this, arguments));
	          }.bind(this, arguments));
	        }.bind(this, arguments));
	      }.bind(this, arguments));
	    }.bind(this, arguments));
	  }.bind(this, arguments));
	};
	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var assign = __webpack_require__(6)

	var fse = {}
	var gfs = __webpack_require__(7)

	// attach fs methods to fse
	Object.keys(gfs).forEach(function (key) {
	  fse[key] = gfs[key]
	})

	var fs = fse

	assign(fs, __webpack_require__(8))
	assign(fs, __webpack_require__(18))
	assign(fs, __webpack_require__(14))
	assign(fs, __webpack_require__(21))
	assign(fs, __webpack_require__(24))
	assign(fs, __webpack_require__(30))
	assign(fs, __webpack_require__(31))
	assign(fs, __webpack_require__(32))
	assign(fs, __webpack_require__(38))
	assign(fs, __webpack_require__(39))
	assign(fs, __webpack_require__(44))

	module.exports = fs

	// maintain backwards compatibility for awhile
	var jsonfile = {}
	Object.defineProperty(jsonfile, 'spaces', {
	  get: function () {
	    return fs.spaces // found in ./json
	  },
	  set: function (val) {
	    fs.spaces = val
	  }
	})

	module.exports.jsonfile = jsonfile // so users of fs-extra can modify jsonFile.spaces


/***/ },
/* 6 */
/***/ function(module, exports) {

	// simple mutable assign
	function assign () {
	  var args = [].slice.call(arguments).filter(function (i) { return i })
	  var dest = args.shift()
	  args.forEach(function (src) {
	    Object.keys(src).forEach(function (key) {
	      dest[key] = src[key]
	    })
	  })

	  return dest
	}

	module.exports = assign


/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("graceful-fs");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  copy: __webpack_require__(9)
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var ncp = __webpack_require__(11)
	var mkdir = __webpack_require__(14)

	function copy (src, dest, options, callback) {
	  if (typeof options === 'function' && !callback) {
	    callback = options
	    options = {}
	  } else if (typeof options === 'function' || options instanceof RegExp) {
	    options = {filter: options}
	  }
	  callback = callback || function () {}
	  options = options || {}

	  // Warn about using preserveTimestamps on 32-bit node:
	  if (options.preserveTimestamps && process.arch === 'ia32') {
	    console.warn('fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n' +
	    'see https://github.com/jprichardson/node-fs-extra/issues/269')
	  }

	  // don't allow src and dest to be the same
	  var basePath = process.cwd()
	  var currentPath = path.resolve(basePath, src)
	  var targetPath = path.resolve(basePath, dest)
	  if (currentPath === targetPath) return callback(new Error('Source and destination must not be the same.'))

	  fs.lstat(src, function (err, stats) {
	    if (err) return callback(err)

	    var dir = null
	    if (stats.isDirectory()) {
	      var parts = dest.split(path.sep)
	      parts.pop()
	      dir = parts.join(path.sep)
	    } else {
	      dir = path.dirname(dest)
	    }

	    fs.exists(dir, function (dirExists) {
	      if (dirExists) return ncp(src, dest, options, callback)
	      mkdir.mkdirs(dir, function (err) {
	        if (err) return callback(err)
	        ncp(src, dest, options, callback)
	      })
	    })
	  })
	}

	module.exports = copy


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// imported from ncp (this is temporary, will rewrite)

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var utimes = __webpack_require__(12)

	function ncp (source, dest, options, callback) {
	  if (!callback) {
	    callback = options
	    options = {}
	  }

	  var basePath = process.cwd()
	  var currentPath = path.resolve(basePath, source)
	  var targetPath = path.resolve(basePath, dest)

	  var filter = options.filter
	  var transform = options.transform
	  var clobber = options.clobber !== false // default true
	  var dereference = options.dereference
	  var preserveTimestamps = options.preserveTimestamps === true

	  var started = 0
	  var finished = 0
	  var running = 0

	  var errored = false

	  startCopy(currentPath)

	  function startCopy (source) {
	    started++
	    if (filter) {
	      if (filter instanceof RegExp) {
	        console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function')
	        if (!filter.test(source)) {
	          return doneOne(true)
	        }
	      } else if (typeof filter === 'function') {
	        if (!filter(source)) {
	          return doneOne(true)
	        }
	      }
	    }
	    return getStats(source)
	  }

	  function getStats (source) {
	    var stat = dereference ? fs.stat : fs.lstat
	    running++
	    stat(source, function (err, stats) {
	      if (err) return onError(err)

	      // We need to get the mode from the stats object and preserve it.
	      var item = {
	        name: source,
	        mode: stats.mode,
	        mtime: stats.mtime, // modified time
	        atime: stats.atime, // access time
	        stats: stats // temporary
	      }

	      if (stats.isDirectory()) {
	        return onDir(item)
	      } else if (stats.isFile() || stats.isCharacterDevice() || stats.isBlockDevice()) {
	        return onFile(item)
	      } else if (stats.isSymbolicLink()) {
	        // Symlinks don't really need to know about the mode.
	        return onLink(source)
	      }
	    })
	  }

	  function onFile (file) {
	    var target = file.name.replace(currentPath, targetPath.replace('$', '$$$$')) // escapes '$' with '$$'
	    isWritable(target, function (writable) {
	      if (writable) {
	        copyFile(file, target)
	      } else {
	        if (clobber) {
	          rmFile(target, function () {
	            copyFile(file, target)
	          })
	        } else {
	          var err = new Error('EEXIST: ' + target + ' already exists.')
	          err.code = 'EEXIST'
	          err.errno = -17
	          err.path = target
	          onError(err)
	        }
	      }
	    })
	  }

	  function copyFile (file, target) {
	    var readStream = fs.createReadStream(file.name)
	    var writeStream = fs.createWriteStream(target, { mode: file.mode })

	    readStream.on('error', onError)
	    writeStream.on('error', onError)

	    if (transform) {
	      transform(readStream, writeStream, file)
	    } else {
	      writeStream.on('open', function () {
	        readStream.pipe(writeStream)
	      })
	    }

	    writeStream.once('finish', function () {
	      fs.chmod(target, file.mode, function (err) {
	        if (err) return onError(err)
	        if (preserveTimestamps) {
	          utimes.utimesMillis(target, file.atime, file.mtime, function (err) {
	            if (err) return onError(err)
	            return doneOne()
	          })
	        } else {
	          doneOne()
	        }
	      })
	    })
	  }

	  function rmFile (file, done) {
	    fs.unlink(file, function (err) {
	      if (err) return onError(err)
	      return done()
	    })
	  }

	  function onDir (dir) {
	    var target = dir.name.replace(currentPath, targetPath.replace('$', '$$$$')) // escapes '$' with '$$'
	    isWritable(target, function (writable) {
	      if (writable) {
	        return mkDir(dir, target)
	      }
	      copyDir(dir.name)
	    })
	  }

	  function mkDir (dir, target) {
	    fs.mkdir(target, dir.mode, function (err) {
	      if (err) return onError(err)
	      // despite setting mode in fs.mkdir, doesn't seem to work
	      // so we set it here.
	      fs.chmod(target, dir.mode, function (err) {
	        if (err) return onError(err)
	        copyDir(dir.name)
	      })
	    })
	  }

	  function copyDir (dir) {
	    fs.readdir(dir, function (err, items) {
	      if (err) return onError(err)
	      items.forEach(function (item) {
	        startCopy(path.join(dir, item))
	      })
	      return doneOne()
	    })
	  }

	  function onLink (link) {
	    var target = link.replace(currentPath, targetPath)
	    fs.readlink(link, function (err, resolvedPath) {
	      if (err) return onError(err)
	      checkLink(resolvedPath, target)
	    })
	  }

	  function checkLink (resolvedPath, target) {
	    if (dereference) {
	      resolvedPath = path.resolve(basePath, resolvedPath)
	    }
	    isWritable(target, function (writable) {
	      if (writable) {
	        return makeLink(resolvedPath, target)
	      }
	      fs.readlink(target, function (err, targetDest) {
	        if (err) return onError(err)

	        if (dereference) {
	          targetDest = path.resolve(basePath, targetDest)
	        }
	        if (targetDest === resolvedPath) {
	          return doneOne()
	        }
	        return rmFile(target, function () {
	          makeLink(resolvedPath, target)
	        })
	      })
	    })
	  }

	  function makeLink (linkPath, target) {
	    fs.symlink(linkPath, target, function (err) {
	      if (err) return onError(err)
	      return doneOne()
	    })
	  }

	  function isWritable (path, done) {
	    fs.lstat(path, function (err) {
	      if (err) {
	        if (err.code === 'ENOENT') return done(true)
	        return done(false)
	      }
	      return done(false)
	    })
	  }

	  function onError (err) {
	    // ensure callback is defined & called only once:
	    if (!errored && callback !== undefined) {
	      errored = true
	      return callback(err)
	    }
	  }

	  function doneOne (skipped) {
	    if (!skipped) running--
	    finished++
	    if ((started === finished) && (running === 0)) {
	      if (callback !== undefined) {
	        return callback(null)
	      }
	    }
	  }
	}

	module.exports = ncp


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var os = __webpack_require__(13)

	// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
	function hasMillisResSync () {
	  var tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))
	  tmpfile = path.join(os.tmpdir(), tmpfile)

	  // 550 millis past UNIX epoch
	  var d = new Date(1435410243862)
	  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')
	  var fd = fs.openSync(tmpfile, 'r+')
	  fs.futimesSync(fd, d, d)
	  fs.closeSync(fd)
	  return fs.statSync(tmpfile).mtime > 1435410243000
	}

	function hasMillisRes (callback) {
	  var tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))
	  tmpfile = path.join(os.tmpdir(), tmpfile)

	  // 550 millis past UNIX epoch
	  var d = new Date(1435410243862)
	  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', function (err) {
	    if (err) return callback(err)
	    fs.open(tmpfile, 'r+', function (err, fd) {
	      if (err) return callback(err)
	      fs.futimes(fd, d, d, function (err) {
	        if (err) return callback(err)
	        fs.close(fd, function (err) {
	          if (err) return callback(err)
	          fs.stat(tmpfile, function (err, stats) {
	            if (err) return callback(err)
	            callback(null, stats.mtime > 1435410243000)
	          })
	        })
	      })
	    })
	  })
	}

	function timeRemoveMillis (timestamp) {
	  if (typeof timestamp === 'number') {
	    return Math.floor(timestamp / 1000) * 1000
	  } else if (timestamp instanceof Date) {
	    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
	  } else {
	    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
	  }
	}

	function utimesMillis (path, atime, mtime, callback) {
	  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
	  fs.open(path, 'r+', function (err, fd) {
	    if (err) return callback(err)
	    fs.futimes(fd, atime, mtime, function (futimesErr) {
	      fs.close(fd, function (closeErr) {
	        if (callback) callback(futimesErr || closeErr)
	      })
	    })
	  })
	}

	module.exports = {
	  hasMillisRes: hasMillisRes,
	  hasMillisResSync: hasMillisResSync,
	  timeRemoveMillis: timeRemoveMillis,
	  utimesMillis: utimesMillis
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  mkdirs: __webpack_require__(15),
	  mkdirsSync: __webpack_require__(17),
	  // alias
	  mkdirp: __webpack_require__(15),
	  mkdirpSync: __webpack_require__(17),
	  ensureDir: __webpack_require__(15),
	  ensureDirSync: __webpack_require__(17)
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var invalidWin32Path = __webpack_require__(16).invalidWin32Path

	var o777 = parseInt('0777', 8)

	function mkdirs (p, opts, callback, made) {
	  if (typeof opts === 'function') {
	    callback = opts
	    opts = {}
	  } else if (!opts || typeof opts !== 'object') {
	    opts = { mode: opts }
	  }

	  if (process.platform === 'win32' && invalidWin32Path(p)) {
	    var errInval = new Error(p + ' contains invalid WIN32 path characters.')
	    errInval.code = 'EINVAL'
	    return callback(errInval)
	  }

	  var mode = opts.mode
	  var xfs = opts.fs || fs

	  if (mode === undefined) {
	    mode = o777 & (~process.umask())
	  }
	  if (!made) made = null

	  callback = callback || function () {}
	  p = path.resolve(p)

	  xfs.mkdir(p, mode, function (er) {
	    if (!er) {
	      made = made || p
	      return callback(null, made)
	    }
	    switch (er.code) {
	      case 'ENOENT':
	        if (path.dirname(p) === p) return callback(er)
	        mkdirs(path.dirname(p), opts, function (er, made) {
	          if (er) callback(er, made)
	          else mkdirs(p, opts, callback, made)
	        })
	        break

	      // In the case of any other error, just see if there's a dir
	      // there already.  If so, then hooray!  If not, then something
	      // is borked.
	      default:
	        xfs.stat(p, function (er2, stat) {
	          // if the stat fails, then that's super weird.
	          // let the original error be the failure reason.
	          if (er2 || !stat.isDirectory()) callback(er, made)
	          else callback(null, made)
	        })
	        break
	    }
	  })
	}

	module.exports = mkdirs


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	var path = __webpack_require__(10)

	// get drive on windows
	function getRootPath (p) {
	  p = path.normalize(path.resolve(p)).split(path.sep)
	  if (p.length > 0) return p[0]
	  else return null
	}

	// http://stackoverflow.com/a/62888/10333 contains more accurate
	// TODO: expand to include the rest
	var INVALID_PATH_CHARS = /[<>:"|?*]/

	function invalidWin32Path (p) {
	  var rp = getRootPath(p)
	  p = p.replace(rp, '')
	  return INVALID_PATH_CHARS.test(p)
	}

	module.exports = {
	  getRootPath: getRootPath,
	  invalidWin32Path: invalidWin32Path
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var invalidWin32Path = __webpack_require__(16).invalidWin32Path

	var o777 = parseInt('0777', 8)

	function mkdirsSync (p, opts, made) {
	  if (!opts || typeof opts !== 'object') {
	    opts = { mode: opts }
	  }

	  var mode = opts.mode
	  var xfs = opts.fs || fs

	  if (process.platform === 'win32' && invalidWin32Path(p)) {
	    var errInval = new Error(p + ' contains invalid WIN32 path characters.')
	    errInval.code = 'EINVAL'
	    throw errInval
	  }

	  if (mode === undefined) {
	    mode = o777 & (~process.umask())
	  }
	  if (!made) made = null

	  p = path.resolve(p)

	  try {
	    xfs.mkdirSync(p, mode)
	    made = made || p
	  } catch (err0) {
	    switch (err0.code) {
	      case 'ENOENT':
	        if (path.dirname(p) === p) throw err0
	        made = mkdirsSync(path.dirname(p), opts, made)
	        mkdirsSync(p, opts, made)
	        break

	      // In the case of any other error, just see if there's a dir
	      // there already.  If so, then hooray!  If not, then something
	      // is borked.
	      default:
	        var stat
	        try {
	          stat = xfs.statSync(p)
	        } catch (err1) {
	          throw err0
	        }
	        if (!stat.isDirectory()) throw err0
	        break
	    }
	  }

	  return made
	}

	module.exports = mkdirsSync


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  copySync: __webpack_require__(19)
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var copyFileSync = __webpack_require__(20)
	var mkdir = __webpack_require__(14)

	function copySync (src, dest, options) {
	  if (typeof options === 'function' || options instanceof RegExp) {
	    options = {filter: options}
	  }

	  options = options || {}
	  options.recursive = !!options.recursive

	  // default to true for now
	  options.clobber = 'clobber' in options ? !!options.clobber : true
	  options.dereference = 'dereference' in options ? !!options.dereference : false
	  options.preserveTimestamps = 'preserveTimestamps' in options ? !!options.preserveTimestamps : false

	  options.filter = options.filter || function () { return true }

	  // Warn about using preserveTimestamps on 32-bit node:
	  if (options.preserveTimestamps && process.arch === 'ia32') {
	    console.warn('fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n' +
	    'see https://github.com/jprichardson/node-fs-extra/issues/269')
	  }

	  var stats = (options.recursive && !options.dereference) ? fs.lstatSync(src) : fs.statSync(src)
	  var destFolder = path.dirname(dest)
	  var destFolderExists = fs.existsSync(destFolder)
	  var performCopy = false

	  if (stats.isFile()) {
	    if (options.filter instanceof RegExp) {
	      console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function')
	      performCopy = options.filter.test(src)
	    } else if (typeof options.filter === 'function') performCopy = options.filter(src)

	    if (performCopy) {
	      if (!destFolderExists) mkdir.mkdirsSync(destFolder)
	      copyFileSync(src, dest, {clobber: options.clobber, preserveTimestamps: options.preserveTimestamps})
	    }
	  } else if (stats.isDirectory()) {
	    if (!fs.existsSync(dest)) mkdir.mkdirsSync(dest)
	    var contents = fs.readdirSync(src)
	    contents.forEach(function (content) {
	      var opts = options
	      opts.recursive = true
	      copySync(path.join(src, content), path.join(dest, content), opts)
	    })
	  } else if (options.recursive && stats.isSymbolicLink()) {
	    var srcPath = fs.readlinkSync(src)
	    fs.symlinkSync(srcPath, dest)
	  }
	}

	module.exports = copySync


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)

	var BUF_LENGTH = 64 * 1024
	var _buff = new Buffer(BUF_LENGTH)

	function copyFileSync (srcFile, destFile, options) {
	  var clobber = options.clobber
	  var preserveTimestamps = options.preserveTimestamps

	  if (fs.existsSync(destFile)) {
	    if (clobber) {
	      fs.unlinkSync(destFile)
	    } else {
	      var err = new Error('EEXIST: ' + destFile + ' already exists.')
	      err.code = 'EEXIST'
	      err.errno = -17
	      err.path = destFile
	      throw err
	    }
	  }

	  var fdr = fs.openSync(srcFile, 'r')
	  var stat = fs.fstatSync(fdr)
	  var fdw = fs.openSync(destFile, 'w', stat.mode)
	  var bytesRead = 1
	  var pos = 0

	  while (bytesRead > 0) {
	    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
	    fs.writeSync(fdw, _buff, 0, bytesRead)
	    pos += bytesRead
	  }

	  if (preserveTimestamps) {
	    fs.futimesSync(fdw, stat.atime, stat.mtime)
	  }

	  fs.closeSync(fdr)
	  fs.closeSync(fdw)
	}

	module.exports = copyFileSync


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var rimraf = __webpack_require__(22)

	function removeSync (dir) {
	  return rimraf.sync(dir, {disableGlob: true})
	}

	function remove (dir, callback) {
	  var options = {disableGlob: true}
	  return callback ? rimraf(dir, options, callback) : rimraf(dir, options, function () {})
	}

	module.exports = {
	  remove: remove,
	  removeSync: removeSync
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = rimraf
	rimraf.sync = rimrafSync

	var assert = __webpack_require__(23)
	var path = __webpack_require__(10)
	var fs = __webpack_require__(7)

	var isWindows = (process.platform === 'win32')

	function defaults (options) {
	  var methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ]
	  methods.forEach(function (m) {
	    options[m] = options[m] || fs[m]
	    m = m + 'Sync'
	    options[m] = options[m] || fs[m]
	  })

	  options.maxBusyTries = options.maxBusyTries || 3
	}

	function rimraf (p, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = {}
	  }

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
	  assert(options, 'rimraf: invalid options argument provided')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')

	  defaults(options)

	  var busyTries = 0

	  rimraf_(p, options, function CB (er) {
	    if (er) {
	      if (isWindows && (er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
	          busyTries < options.maxBusyTries) {
	        busyTries++
	        var time = busyTries * 100
	        // try again, with the same exact callback as this one.
	        return setTimeout(function () {
	          rimraf_(p, options, CB)
	        }, time)
	      }

	      // already gone
	      if (er.code === 'ENOENT') er = null
	    }

	    cb(er)
	  })
	}

	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, function (er, st) {
	    if (er && er.code === 'ENOENT') {
	      return cb(null)
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er && er.code === 'EPERM' && isWindows) {
	      fixWinEPERM(p, options, er, cb)
	    }

	    if (st && st.isDirectory()) {
	      return rmdir(p, options, er, cb)
	    }

	    options.unlink(p, function (er) {
	      if (er) {
	        if (er.code === 'ENOENT') {
	          return cb(null)
	        }
	        if (er.code === 'EPERM') {
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        }
	        if (er.code === 'EISDIR') {
	          return rmdir(p, options, er, cb)
	        }
	      }
	      return cb(er)
	    })
	  })
	}

	function fixWinEPERM (p, options, er, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	  if (er) {
	    assert(er instanceof Error)
	  }

	  options.chmod(p, 666, function (er2) {
	    if (er2) {
	      cb(er2.code === 'ENOENT' ? null : er)
	    } else {
	      options.stat(p, function (er3, stats) {
	        if (er3) {
	          cb(er3.code === 'ENOENT' ? null : er)
	        } else if (stats.isDirectory()) {
	          rmdir(p, options, er, cb)
	        } else {
	          options.unlink(p, cb)
	        }
	      })
	    }
	  })
	}

	function fixWinEPERMSync (p, options, er) {
	  assert(p)
	  assert(options)
	  if (er) {
	    assert(er instanceof Error)
	  }

	  try {
	    options.chmodSync(p, 666)
	  } catch (er2) {
	    if (er2.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  try {
	    var stats = options.statSync(p)
	  } catch (er3) {
	    if (er3.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  if (stats.isDirectory()) {
	    rmdirSync(p, options, er)
	  } else {
	    options.unlinkSync(p)
	  }
	}

	function rmdir (p, options, originalEr, cb) {
	  assert(p)
	  assert(options)
	  if (originalEr) {
	    assert(originalEr instanceof Error)
	  }
	  assert(typeof cb === 'function')

	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, function (er) {
	    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
	      rmkids(p, options, cb)
	    } else if (er && er.code === 'ENOTDIR') {
	      cb(originalEr)
	    } else {
	      cb(er)
	    }
	  })
	}

	function rmkids (p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  options.readdir(p, function (er, files) {
	    if (er) {
	      return cb(er)
	    }
	    var n = files.length
	    if (n === 0) {
	      return options.rmdir(p, cb)
	    }
	    var errState
	    files.forEach(function (f) {
	      rimraf(path.join(p, f), options, function (er) {
	        if (errState) {
	          return
	        }
	        if (er) {
	          return cb(errState = er)
	        }
	        if (--n === 0) {
	          options.rmdir(p, cb)
	        }
	      })
	    })
	  })
	}

	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  options = options || {}
	  defaults(options)

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')

	  try {
	    var st = options.lstatSync(p)
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er.code === 'EPERM' && isWindows) {
	      fixWinEPERMSync(p, options, er)
	    }
	  }

	  try {
	    // sunos lets the root user unlink directories, which is... weird.
	    if (st && st.isDirectory()) {
	      rmdirSync(p, options, null)
	    } else {
	      options.unlinkSync(p)
	    }
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    }
	    if (er.code === 'EPERM') {
	      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	    }
	    if (er.code !== 'EISDIR') {
	      throw er
	    }
	    rmdirSync(p, options, er)
	  }
	}

	function rmdirSync (p, options, originalEr) {
	  assert(p)
	  assert(options)
	  if (originalEr) {
	    assert(originalEr instanceof Error)
	  }

	  try {
	    options.rmdirSync(p)
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    }
	    if (er.code === 'ENOTDIR') {
	      throw originalEr
	    }
	    if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
	      rmkidsSync(p, options)
	    }
	  }
	}

	function rmkidsSync (p, options) {
	  assert(p)
	  assert(options)
	  options.readdirSync(p).forEach(function (f) {
	    rimrafSync(path.join(p, f), options)
	  })
	  options.rmdirSync(p, options)
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var jsonFile = __webpack_require__(25)

	jsonFile.outputJsonSync = __webpack_require__(28)
	jsonFile.outputJson = __webpack_require__(29)
	// aliases
	jsonFile.outputJSONSync = __webpack_require__(28)
	jsonFile.outputJSON = __webpack_require__(29)

	module.exports = jsonFile


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var jsonFile = __webpack_require__(26)

	module.exports = {
	  // jsonfile exports
	  readJson: jsonFile.readFile,
	  readJSON: jsonFile.readFile,
	  readJsonSync: jsonFile.readFileSync,
	  readJSONSync: jsonFile.readFileSync,
	  writeJson: jsonFile.writeFile,
	  writeJSON: jsonFile.writeFile,
	  writeJsonSync: jsonFile.writeFileSync,
	  writeJSONSync: jsonFile.writeFileSync,
	  spaces: 2 // default in fs-extra
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var _fs
	try {
	  _fs = __webpack_require__(7)
	} catch (_) {
	  _fs = __webpack_require__(27)
	}

	function readFile (file, options, callback) {
	  if (callback == null) {
	    callback = options
	    options = {}
	  }

	  if (typeof options === 'string') {
	    options = {encoding: options}
	  }

	  options = options || {}
	  var fs = options.fs || _fs

	  var shouldThrow = true
	  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead
	  if ('passParsingErrors' in options) {
	    shouldThrow = options.passParsingErrors
	  } else if ('throws' in options) {
	    shouldThrow = options.throws
	  }

	  fs.readFile(file, options, function (err, data) {
	    if (err) return callback(err)

	    data = stripBom(data)

	    var obj
	    try {
	      obj = JSON.parse(data, options ? options.reviver : null)
	    } catch (err2) {
	      if (shouldThrow) {
	        err2.message = file + ': ' + err2.message
	        return callback(err2)
	      } else {
	        return callback(null, null)
	      }
	    }

	    callback(null, obj)
	  })
	}

	function readFileSync (file, options) {
	  options = options || {}
	  if (typeof options === 'string') {
	    options = {encoding: options}
	  }

	  var fs = options.fs || _fs

	  var shouldThrow = true
	  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead
	  if ('passParsingErrors' in options) {
	    shouldThrow = options.passParsingErrors
	  } else if ('throws' in options) {
	    shouldThrow = options.throws
	  }

	  var content = fs.readFileSync(file, options)
	  content = stripBom(content)

	  try {
	    return JSON.parse(content, options.reviver)
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = file + ': ' + err.message
	      throw err
	    } else {
	      return null
	    }
	  }
	}

	function writeFile (file, obj, options, callback) {
	  if (callback == null) {
	    callback = options
	    options = {}
	  }
	  options = options || {}
	  var fs = options.fs || _fs

	  var spaces = typeof options === 'object' && options !== null
	    ? 'spaces' in options
	    ? options.spaces : this.spaces
	    : this.spaces

	  var str = ''
	  try {
	    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\n'
	  } catch (err) {
	    if (callback) return callback(err, null)
	  }

	  fs.writeFile(file, str, options, callback)
	}

	function writeFileSync (file, obj, options) {
	  options = options || {}
	  var fs = options.fs || _fs

	  var spaces = typeof options === 'object' && options !== null
	    ? 'spaces' in options
	    ? options.spaces : this.spaces
	    : this.spaces

	  var str = JSON.stringify(obj, options.replacer, spaces) + '\n'
	  // not sure if fs.writeFileSync returns anything, but just in case
	  return fs.writeFileSync(file, str, options)
	}

	function stripBom (content) {
	  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
	  if (Buffer.isBuffer(content)) content = content.toString('utf8')
	  content = content.replace(/^\uFEFF/, '')
	  return content
	}

	var jsonfile = {
	  spaces: null,
	  readFile: readFile,
	  readFileSync: readFileSync,
	  writeFile: writeFile,
	  writeFileSync: writeFileSync
	}

	module.exports = jsonfile


/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var jsonFile = __webpack_require__(25)
	var mkdir = __webpack_require__(14)

	function outputJsonSync (file, data, options) {
	  var dir = path.dirname(file)

	  if (!fs.existsSync(dir)) {
	    mkdir.mkdirsSync(dir)
	  }

	  jsonFile.writeJsonSync(file, data, options)
	}

	module.exports = outputJsonSync


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)
	var jsonFile = __webpack_require__(25)
	var mkdir = __webpack_require__(14)

	function outputJson (file, data, options, callback) {
	  if (typeof options === 'function') {
	    callback = options
	    options = {}
	  }

	  var dir = path.dirname(file)

	  fs.exists(dir, function (itDoes) {
	    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

	    mkdir.mkdirs(dir, function (err) {
	      if (err) return callback(err)
	      jsonFile.writeJson(file, data, options, callback)
	    })
	  })
	}

	module.exports = outputJson


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// most of this code was written by Andrew Kelley
	// licensed under the BSD license: see
	// https://github.com/andrewrk/node-mv/blob/master/package.json

	// this needs a cleanup

	var fs = __webpack_require__(7)
	var ncp = __webpack_require__(11)
	var path = __webpack_require__(10)
	var remove = __webpack_require__(21).remove
	var mkdirp = __webpack_require__(14).mkdirs

	function mv (source, dest, options, callback) {
	  if (typeof options === 'function') {
	    callback = options
	    options = {}
	  }

	  var shouldMkdirp = ('mkdirp' in options) ? options.mkdirp : true
	  var clobber = ('clobber' in options) ? options.clobber : false

	  var limit = options.limit || 16

	  if (shouldMkdirp) {
	    mkdirs()
	  } else {
	    doRename()
	  }

	  function mkdirs () {
	    mkdirp(path.dirname(dest), function (err) {
	      if (err) return callback(err)
	      doRename()
	    })
	  }

	  function doRename () {
	    if (clobber) {
	      fs.rename(source, dest, function (err) {
	        if (!err) return callback()

	        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
	          remove(dest, function (err) {
	            if (err) return callback(err)
	            options.clobber = false // just clobbered it, no need to do it again
	            mv(source, dest, options, callback)
	          })
	          return
	        }

	        // weird Windows shit
	        if (err.code === 'EPERM') {
	          setTimeout(function () {
	            remove(dest, function (err) {
	              if (err) return callback(err)
	              options.clobber = false
	              mv(source, dest, options, callback)
	            })
	          }, 200)
	          return
	        }

	        if (err.code !== 'EXDEV') return callback(err)
	        moveAcrossDevice(source, dest, clobber, limit, callback)
	      })
	    } else {
	      fs.link(source, dest, function (err) {
	        if (err) {
	          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM') {
	            moveAcrossDevice(source, dest, clobber, limit, callback)
	            return
	          }
	          callback(err)
	          return
	        }
	        fs.unlink(source, callback)
	      })
	    }
	  }
	}

	function moveAcrossDevice (source, dest, clobber, limit, callback) {
	  fs.stat(source, function (err, stat) {
	    if (err) {
	      callback(err)
	      return
	    }

	    if (stat.isDirectory()) {
	      moveDirAcrossDevice(source, dest, clobber, limit, callback)
	    } else {
	      moveFileAcrossDevice(source, dest, clobber, limit, callback)
	    }
	  })
	}

	function moveFileAcrossDevice (source, dest, clobber, limit, callback) {
	  var outFlags = clobber ? 'w' : 'wx'
	  var ins = fs.createReadStream(source)
	  var outs = fs.createWriteStream(dest, {flags: outFlags})

	  ins.on('error', function (err) {
	    ins.destroy()
	    outs.destroy()
	    outs.removeListener('close', onClose)

	    // may want to create a directory but `out` line above
	    // creates an empty file for us: See #108
	    // don't care about error here
	    fs.unlink(dest, function () {
	      // note: `err` here is from the input stream errror
	      if (err.code === 'EISDIR' || err.code === 'EPERM') {
	        moveDirAcrossDevice(source, dest, clobber, limit, callback)
	      } else {
	        callback(err)
	      }
	    })
	  })

	  outs.on('error', function (err) {
	    ins.destroy()
	    outs.destroy()
	    outs.removeListener('close', onClose)
	    callback(err)
	  })

	  outs.once('close', onClose)
	  ins.pipe(outs)

	  function onClose () {
	    fs.unlink(source, callback)
	  }
	}

	function moveDirAcrossDevice (source, dest, clobber, limit, callback) {
	  var options = {
	    stopOnErr: true,
	    clobber: false,
	    limit: limit
	  }

	  function startNcp () {
	    ncp(source, dest, options, function (errList) {
	      if (errList) return callback(errList[0])
	      remove(source, callback)
	    })
	  }

	  if (clobber) {
	    remove(dest, function (err) {
	      if (err) return callback(err)
	      startNcp()
	    })
	  } else {
	    startNcp()
	  }
	}

	module.exports = {
	  move: mv
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(27)
	var path = __webpack_require__(10)
	var mkdir = __webpack_require__(14)
	var remove = __webpack_require__(21)

	function emptyDir (dir, callback) {
	  callback = callback || function () {}
	  fs.readdir(dir, function (err, items) {
	    if (err) return mkdir.mkdirs(dir, callback)

	    items = items.map(function (item) {
	      return path.join(dir, item)
	    })

	    deleteItem()

	    function deleteItem () {
	      var item = items.pop()
	      if (!item) return callback()
	      remove.remove(item, function (err) {
	        if (err) return callback(err)
	        deleteItem()
	      })
	    }
	  })
	}

	function emptyDirSync (dir) {
	  var items
	  try {
	    items = fs.readdirSync(dir)
	  } catch (err) {
	    return mkdir.mkdirsSync(dir)
	  }

	  items.forEach(function (item) {
	    item = path.join(dir, item)
	    remove.removeSync(item)
	  })
	}

	module.exports = {
	  emptyDirSync: emptyDirSync,
	  emptydirSync: emptyDirSync,
	  emptyDir: emptyDir,
	  emptydir: emptyDir
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var file = __webpack_require__(33)
	var link = __webpack_require__(34)
	var symlink = __webpack_require__(35)

	module.exports = {
	  // file
	  createFile: file.createFile,
	  createFileSync: file.createFileSync,
	  ensureFile: file.createFile,
	  ensureFileSync: file.createFileSync,
	  // link
	  createLink: link.createLink,
	  createLinkSync: link.createLinkSync,
	  ensureLink: link.createLink,
	  ensureLinkSync: link.createLinkSync,
	  // symlink
	  createSymlink: symlink.createSymlink,
	  createSymlinkSync: symlink.createSymlinkSync,
	  ensureSymlink: symlink.createSymlink,
	  ensureSymlinkSync: symlink.createSymlinkSync
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(10)
	var fs = __webpack_require__(7)
	var mkdir = __webpack_require__(14)

	function createFile (file, callback) {
	  function makeFile () {
	    fs.writeFile(file, '', function (err) {
	      if (err) return callback(err)
	      callback()
	    })
	  }

	  fs.exists(file, function (fileExists) {
	    if (fileExists) return callback()
	    var dir = path.dirname(file)
	    fs.exists(dir, function (dirExists) {
	      if (dirExists) return makeFile()
	      mkdir.mkdirs(dir, function (err) {
	        if (err) return callback(err)
	        makeFile()
	      })
	    })
	  })
	}

	function createFileSync (file) {
	  if (fs.existsSync(file)) return

	  var dir = path.dirname(file)
	  if (!fs.existsSync(dir)) {
	    mkdir.mkdirsSync(dir)
	  }

	  fs.writeFileSync(file, '')
	}

	module.exports = {
	  createFile: createFile,
	  createFileSync: createFileSync,
	  // alias
	  ensureFile: createFile,
	  ensureFileSync: createFileSync
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(10)
	var fs = __webpack_require__(7)
	var mkdir = __webpack_require__(14)

	function createLink (srcpath, dstpath, callback) {
	  function makeLink (srcpath, dstpath) {
	    fs.link(srcpath, dstpath, function (err) {
	      if (err) return callback(err)
	      callback(null)
	    })
	  }

	  fs.exists(dstpath, function (destinationExists) {
	    if (destinationExists) return callback(null)
	    fs.lstat(srcpath, function (err, stat) {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureLink')
	        return callback(err)
	      }

	      var dir = path.dirname(dstpath)
	      fs.exists(dir, function (dirExists) {
	        if (dirExists) return makeLink(srcpath, dstpath)
	        mkdir.mkdirs(dir, function (err) {
	          if (err) return callback(err)
	          makeLink(srcpath, dstpath)
	        })
	      })
	    })
	  })
	}

	function createLinkSync (srcpath, dstpath, callback) {
	  var destinationExists = fs.existsSync(dstpath)
	  if (destinationExists) return undefined

	  try {
	    fs.lstatSync(srcpath)
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureLink')
	    throw err
	  }

	  var dir = path.dirname(dstpath)
	  var dirExists = fs.existsSync(dir)
	  if (dirExists) return fs.linkSync(srcpath, dstpath)
	  mkdir.mkdirsSync(dir)

	  return fs.linkSync(srcpath, dstpath)
	}

	module.exports = {
	  createLink: createLink,
	  createLinkSync: createLinkSync,
	  // alias
	  ensureLink: createLink,
	  ensureLinkSync: createLinkSync
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(10)
	var fs = __webpack_require__(7)
	var _mkdirs = __webpack_require__(14)
	var mkdirs = _mkdirs.mkdirs
	var mkdirsSync = _mkdirs.mkdirsSync

	var _symlinkPaths = __webpack_require__(36)
	var symlinkPaths = _symlinkPaths.symlinkPaths
	var symlinkPathsSync = _symlinkPaths.symlinkPathsSync

	var _symlinkType = __webpack_require__(37)
	var symlinkType = _symlinkType.symlinkType
	var symlinkTypeSync = _symlinkType.symlinkTypeSync

	function createSymlink (srcpath, dstpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback
	  type = (typeof type === 'function') ? false : type

	  fs.exists(dstpath, function (destinationExists) {
	    if (destinationExists) return callback(null)
	    symlinkPaths(srcpath, dstpath, function (err, relative) {
	      if (err) return callback(err)
	      srcpath = relative.toDst
	      symlinkType(relative.toCwd, type, function (err, type) {
	        if (err) return callback(err)
	        var dir = path.dirname(dstpath)
	        fs.exists(dir, function (dirExists) {
	          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
	          mkdirs(dir, function (err) {
	            if (err) return callback(err)
	            fs.symlink(srcpath, dstpath, type, callback)
	          })
	        })
	      })
	    })
	  })
	}

	function createSymlinkSync (srcpath, dstpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback
	  type = (typeof type === 'function') ? false : type

	  var destinationExists = fs.existsSync(dstpath)
	  if (destinationExists) return undefined

	  var relative = symlinkPathsSync(srcpath, dstpath)
	  srcpath = relative.toDst
	  type = symlinkTypeSync(relative.toCwd, type)
	  var dir = path.dirname(dstpath)
	  var exists = fs.existsSync(dir)
	  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
	  mkdirsSync(dir)
	  return fs.symlinkSync(srcpath, dstpath, type)
	}

	module.exports = {
	  createSymlink: createSymlink,
	  createSymlinkSync: createSymlinkSync,
	  // alias
	  ensureSymlink: createSymlink,
	  ensureSymlinkSync: createSymlinkSync
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(10)
	// path.isAbsolute shim for Node.js 0.10 support
	var fs = __webpack_require__(7)

	/**
	 * Function that returns two types of paths, one relative to symlink, and one
	 * relative to the current working directory. Checks if path is absolute or
	 * relative. If the path is relative, this function checks if the path is
	 * relative to symlink or relative to current working directory. This is an
	 * initiative to find a smarter `srcpath` to supply when building symlinks.
	 * This allows you to determine which path to use out of one of three possible
	 * types of source paths. The first is an absolute path. This is detected by
	 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
	 * see if it exists. If it does it's used, if not an error is returned
	 * (callback)/ thrown (sync). The other two options for `srcpath` are a
	 * relative url. By default Node's `fs.symlink` works by creating a symlink
	 * using `dstpath` and expects the `srcpath` to be relative to the newly
	 * created symlink. If you provide a `srcpath` that does not exist on the file
	 * system it results in a broken symlink. To minimize this, the function
	 * checks to see if the 'relative to symlink' source file exists, and if it
	 * does it will use it. If it does not, it checks if there's a file that
	 * exists that is relative to the current working directory, if does its used.
	 * This preserves the expectations of the original fs.symlink spec and adds
	 * the ability to pass in `relative to current working direcotry` paths.
	 */

	function symlinkPaths (srcpath, dstpath, callback) {
	  if (path.isAbsolute(srcpath)) {
	    return fs.lstat(srcpath, function (err, stat) {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureSymlink')
	        return callback(err)
	      }
	      return callback(null, {
	        'toCwd': srcpath,
	        'toDst': srcpath
	      })
	    })
	  } else {
	    var dstdir = path.dirname(dstpath)
	    var relativeToDst = path.join(dstdir, srcpath)
	    return fs.exists(relativeToDst, function (exists) {
	      if (exists) {
	        return callback(null, {
	          'toCwd': relativeToDst,
	          'toDst': srcpath
	        })
	      } else {
	        return fs.lstat(srcpath, function (err, stat) {
	          if (err) {
	            err.message = err.message.replace('lstat', 'ensureSymlink')
	            return callback(err)
	          }
	          return callback(null, {
	            'toCwd': srcpath,
	            'toDst': path.relative(dstdir, srcpath)
	          })
	        })
	      }
	    })
	  }
	}

	function symlinkPathsSync (srcpath, dstpath) {
	  var exists
	  if (path.isAbsolute(srcpath)) {
	    exists = fs.existsSync(srcpath)
	    if (!exists) throw new Error('absolute srcpath does not exist')
	    return {
	      'toCwd': srcpath,
	      'toDst': srcpath
	    }
	  } else {
	    var dstdir = path.dirname(dstpath)
	    var relativeToDst = path.join(dstdir, srcpath)
	    exists = fs.existsSync(relativeToDst)
	    if (exists) {
	      return {
	        'toCwd': relativeToDst,
	        'toDst': srcpath
	      }
	    } else {
	      exists = fs.existsSync(srcpath)
	      if (!exists) throw new Error('relative srcpath does not exist')
	      return {
	        'toCwd': srcpath,
	        'toDst': path.relative(dstdir, srcpath)
	      }
	    }
	  }
	}

	module.exports = {
	  'symlinkPaths': symlinkPaths,
	  'symlinkPathsSync': symlinkPathsSync
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)

	function symlinkType (srcpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback
	  type = (typeof type === 'function') ? false : type
	  if (type) return callback(null, type)
	  fs.lstat(srcpath, function (err, stats) {
	    if (err) return callback(null, 'file')
	    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
	    callback(null, type)
	  })
	}

	function symlinkTypeSync (srcpath, type) {
	  if (type) return type
	  try {
	    var stats = fs.lstatSync(srcpath)
	  } catch (e) {
	    return 'file'
	  }
	  return (stats && stats.isDirectory()) ? 'dir' : 'file'
	}

	module.exports = {
	  symlinkType: symlinkType,
	  symlinkTypeSync: symlinkTypeSync
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(10)
	var fs = __webpack_require__(7)
	var mkdir = __webpack_require__(14)

	function outputFile (file, data, encoding, callback) {
	  if (typeof encoding === 'function') {
	    callback = encoding
	    encoding = 'utf8'
	  }

	  var dir = path.dirname(file)
	  fs.exists(dir, function (itDoes) {
	    if (itDoes) return fs.writeFile(file, data, encoding, callback)

	    mkdir.mkdirs(dir, function (err) {
	      if (err) return callback(err)

	      fs.writeFile(file, data, encoding, callback)
	    })
	  })
	}

	function outputFileSync (file, data, encoding) {
	  var dir = path.dirname(file)
	  if (fs.existsSync(dir)) {
	    return fs.writeFileSync.apply(fs, arguments)
	  }
	  mkdir.mkdirsSync(dir)
	  fs.writeFileSync.apply(fs, arguments)
	}

	module.exports = {
	  outputFile: outputFile,
	  outputFileSync: outputFileSync
	}


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var klaw = __webpack_require__(40)

	module.exports = {
	  walk: klaw
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(23)
	var fs
	try {
	  fs = __webpack_require__(7)
	} catch (e) {
	  fs = __webpack_require__(27)
	}
	var path = __webpack_require__(10)
	var Readable = __webpack_require__(41).Readable
	var util = __webpack_require__(42)
	var assign = __webpack_require__(43)

	function Walker (dir, options) {
	  assert.strictEqual(typeof dir, 'string', '`dir` parameter should be of type string. Got type: ' + typeof dir)
	  var defaultStreamOptions = { objectMode: true }
	  var defaultOpts = { queueMethod: 'shift', pathSorter: undefined, filter: undefined }
	  options = assign(defaultOpts, options, defaultStreamOptions)

	  Readable.call(this, options)
	  this.root = path.resolve(dir)
	  this.paths = [this.root]
	  this.options = options
	  this.fs = options.fs || fs // mock-fs
	}
	util.inherits(Walker, Readable)

	Walker.prototype._read = function () {
	  if (this.paths.length === 0) return this.push(null)
	  var self = this
	  var pathItem = this.paths[this.options.queueMethod]()

	  self.fs.lstat(pathItem, function (err, stats) {
	    var item = { path: pathItem, stats: stats }
	    if (err) return self.emit('error', err, item)
	    if (!stats.isDirectory()) return self.push(item)

	    self.fs.readdir(pathItem, function (err, pathItems) {
	      if (err) {
	        self.push(item)
	        return self.emit('error', err, item)
	      }

	      pathItems = pathItems.map(function (part) { return path.join(pathItem, part) })
	      if (self.options.filter) pathItems = pathItems.filter(self.options.filter)
	      if (self.options.pathSorter) pathItems.sort(self.options.pathSorter)
	      pathItems.forEach(function (pi) { self.paths.push(pi) })

	      self.push(item)
	    })
	  })
	}

	function walk (root, options) {
	  return new Walker(root, options)
	}

	module.exports = walk


/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 43 */
/***/ function(module, exports) {

	// simple mutable assign (extracted from fs-extra)
	// I really like object-assign package, but I wanted a lean package with zero deps
	function _assign () {
	  var args = [].slice.call(arguments).filter(function (i) { return i })
	  var dest = args.shift()
	  args.forEach(function (src) {
	    Object.keys(src).forEach(function (key) {
	      dest[key] = src[key]
	    })
	  })

	  return dest
	}

	// thank you baby Jesus for Node v4 and Object.assign
	module.exports = Object.assign || _assign


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(7)
	var path = __webpack_require__(10)

	var walkSync = function (dir, filelist) {
	  var files = fs.readdirSync(dir)
	  filelist = filelist || []
	  files.forEach(function (file) {
	    var nestedPath = path.join(dir, file)
	    if (fs.lstatSync(nestedPath).isDirectory()) {
	      filelist = walkSync(nestedPath, filelist)
	    } else {
	      filelist.push(nestedPath)
	    }
	  })
	  return filelist
	}

	module.exports = {
	  walkSync: walkSync
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var fs = __webpack_require__(5);

	var _ = function _(from, to, cb) {
	    var handle_response = function handle_response() {
	        cb();
	    };

	    fs.move(from, to, handle_response);
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var fs = __webpack_require__(5);

	var _ = function _(from, to, cb) {
	    var handle_response = function handle_response() {
	        cb();
	    };

	    fs.copy(from, to, handle_response);
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var gulp = __webpack_require__(48);
	var debug = __webpack_require__(49);
	var insert = __webpack_require__(50);
	var replace = __webpack_require__(51);
	var babel = __webpack_require__(52);
	var continuation = __webpack_require__(53);

	var _ = function _(root_path, cb) {
	    gulp.task('_', function () {
	        return gulp.src([root_path + '/**/*.es6', '!**/expected/**', '!**/node_modules/**', '!**/*_data/**/*']).pipe(insert.prepend('const word_wrap = require(\'word-wrap\');\n')).pipe(insert.prepend('const ERR = require(\'async-stacktrace\');\n')).pipe(replace(/\[project\_name\]/g, 'lambda_pattern')).pipe(replace(/cont\(.*err.*\).*;/g, '$&\n                if (ERR(err, cb)) {\n                    return;}\n                    ')).pipe(replace(/const cb = \(err.*\) \=> \{/g, '$&\n            if (err) {\n                console.log(word_wrap(err.stack.replace(/\\\\/g, \'\\\\ \'), {\n                    trim: true,\n                    width: 80})\n                .split(\'\\n\').forEach((stack_line) => {\n                    console.log(stack_line\n                        .replace(/\\\\ /g, \'\\\\\')\n                        .replace(/ at/g, \'\\nat\')\n                        .replace(/Error:/g, \'\\nError:\'));}));\n                t.fail();\n                return t.end();}\n            ')).pipe(gulp.dest(root_path)).on('end', cb).on('error', cb);
	    });

	    gulp.start('_');
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = require("gulp");

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = require("gulp-debug");

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = require("gulp-insert");

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = require("gulp-replace");

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = require("gulp-babel");

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = require("gulp-continuation");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ERR = __webpack_require__(1);
	var word_wrap = __webpack_require__(2);
	var gulp = __webpack_require__(48);
	var debug = __webpack_require__(49);
	var insert = __webpack_require__(50);
	var replace = __webpack_require__(51);
	var babel = __webpack_require__(52);
	var continuation = __webpack_require__(53);

	var _ = function _(root_path, cb) {
	    gulp.task('_', function () {
	        return gulp.src([root_path + '/**/*.es6', '!**/expected/**', '!**/node_modules/**', '!**/*_data/**/*']).pipe(babel({ presets: ['es2015'] })).pipe(continuation()).pipe(gulp.dest(root_path)).on('end', cb).on('error', cb);
	    });

	    gulp.start('_');
	};

	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var ERR, word_wrap, fs, _;
	'use strict';
	ERR = __webpack_require__(1);
	word_wrap = __webpack_require__(2);
	fs = __webpack_require__(5);
	_ = function _(root_path, cb) {
	  var main_path, err, main_file;
	  main_path = root_path + '/_.es6';
	  fs.readFile(main_path, function (arguments, _$param0, _$param1) {
	    err = _$param0;
	    main_file = _$param1;
	    if (ERR(err, cb)) {
	      return;
	    }
	    main_file = main_file + '\nif (!module.parent) {\n    lambda_pattern(function (er) {\n        if (er) {\n           console.log(er.toString());\n        }\n    });\n}';
	    fs.writeFile(main_path, main_file, cb);
	  }.bind(this, arguments));
	};
	module.exports = _;
	/* Generated by Continuation.js v0.1.7 */

/***/ }
/******/ ]);